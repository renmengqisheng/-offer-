题目描述

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e", "1a3.14", "1.2.3", "+-5"和"12e+4.3"都不是。

思路：

解决字符串问题尽量不要使用循环，会使问题复杂化从而难以进行判断，应该从左往右依次进行解析，必要时还可以将字符串分块。

表示数值的字符串遵循模式 A[.[B]][e|EC] 或 .B[e|EC] 。其中A是数值的整数部分，B是数值的小数部分，C是数值的整数部分，e和E是终结符表示带科学计数法(10的几次幂)，A和C能以终结符+和-开头，也可以像B一样是普通的数位串。

数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是整数(可以有正负号,也可以没有)，而B是一个无符号整数。

小数点前后必须有一个整数，但不用两个整数都有。e或E前后都必须要有整数。

在开头尝试扫描一下有符号整数，如果扫描到就扫完了A,接下来要遇到.B或者指数部分或者啥也没有，如果没扫到,接下来就必须要遇到.B。

如果出现'.',则接下来是数字的小数部分,即B部分。越过这个'.'，如果之前numeric为真,说明扫过了A,即便有.有没有B也无所谓,如'233.'即233.0合法。没扫过A时,一定要扫'.'然后扫B部分,扫B部分用无符号整数,如'.233'即0.233合法。

如果没有扫到A也没有出现'.',这时候已经非法了。可以在这里直接返回,但后面的代码也适用,不会将false变成true。书上就是没有直接返回,接着用后面的代码,因为都是与运算,所以没关系。总之,到现在为止如果numeric为true最后不一定true,但是为false最后一定false了。所以不妨加个剪枝提高效率。注意!加了这个剪枝以后,后面实际上就没必要再和numeric做&&运算了,但这里还是保留书上的代码。

如果出现'e'或者'E',接下来跟着的是数字的指数部分，越过这个'e'或者'E'。下面一行代码用&&的原因：当e或E前面没有数字时,整个字符串不能表示数字,例如.e1、e1；
当e或E后面没有整数时,整个字符串不能表示数字,例如12e、12e+5.4。当然也可以不出现指数部分,那么后面就要直接结束了。结束时还要判断一下已经走到了字符串结尾,而不会有遗留的未匹配到的部分。
