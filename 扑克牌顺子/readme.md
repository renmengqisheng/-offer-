题目描述

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)。他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

思路一：

1、排序；

2、计算0的个数；

3、如果出现对子，则不是顺子；

4、计算所有相邻数字间隔总数；

4、如果0的个数大于等于相邻数字间隔总数，就是顺子，否则不是顺子。


思路二：

max 记录最大值；min 记录最小值；min,max 都不记0。

满足条件:

1.max - min <5；

2.除0外没有重复的数字(牌)；

3.数组长度为5。

如何保证MAX－MIN < 5  就一定是顺子呢?

1、max - min < 5，即最大差值是4，确保数组元素值不会太分散。

2、除0外没有重复的数，确保数组元素值不会太密集(重复)。

两个条件一起，确保了该数组一定是顺子。


用类似哈希表的数组来判断是否有除了0以外的重复数，可以用bit做标记，节省空间，效率也应该高一些。max记录最大值，min记录最小值，在判断是否差<5。

bitmap排序原理：

假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0。

然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01<<(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending），因为是从零开始的，所以要把第五位置为1。

然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1。

然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。

其实就是把计数排序用的统计数组的每个单位缩小成bit级别的布尔数组。
